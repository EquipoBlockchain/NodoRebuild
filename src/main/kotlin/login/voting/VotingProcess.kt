package login.voting

import fileAccess.fileTypeJSON.voteInfoUnit.VoteInfoUnitEntry
import mu.KotlinLogging

private val logger = KotlinLogging.logger {}

/**
 * This class allows allocating a [VoteInfoUnitEntry] object initialized outside the constructor, requiring to call
 * [votingConsensus] first.
 *
 * - [dummy] is a representation of the entry with the most frequency on the list generated by [VotingInformation].
 */
class VotingProcess {
    lateinit var dummy : VoteInfoUnitEntry

    /**
     * Determines a consensus from the vote information list generated by [VotingInformation].
     *
     * KotlinLogging Implemented.
     */
    fun votingConsensus() {
        val votingInformation = VotingInformation()

        var maxFrequency = 1
        var counter      = 0

        if(votingInformation.generateVotingInfo()){
            val totalEntries = votingInformation.voteInformationList.size
            val minimumFrequencyRequired = ((totalEntries)/3)*2
            votingInformation.voteInformationList.forEachIndexed { index1, voteInfoUnit ->
                for (index2 in index1 until totalEntries) {
                    if (voteInfoUnit.entry == votingInformation.voteInformationList[index2].entry) {
                        counter++
                    }
                    if (maxFrequency < counter) {
                        maxFrequency = counter
                        dummy        = voteInfoUnit.entry
                    }
                }
                counter = 0
            }
            logger.info { "Pattern frequencies analyzed: $totalEntries" }
            logger.info { "Minimum matching pattern frequency expected: $minimumFrequencyRequired" }
            logger.info { "Highest matching pattern frequency reached: $maxFrequency" }
            if (maxFrequency == totalEntries) {
                logger.info { "KAWORU pattern detected. Voting information consensus unanimous." }
                logger.info { "Resulting dummy plug: $dummy" }
            } else if (minimumFrequencyRequired <= maxFrequency) {
                logger.warn { "REI pattern detected. Voting information consensus reached." }
                logger.info { "Resulting dummy plug: $dummy" }
                votingInformation.voteInformationList.forEach { voteInfoUnit ->
                    if (voteInfoUnit.entry != dummy) {
                        logger.warn { "Dissident node found: ${voteInfoUnit.originID}" }
                        logger.warn { "Mismatching pattern: ${voteInfoUnit.entry}" }
                    }
                }
            } else {
                logger.error { "UNSTABLE REI pattern detected. Voting information consensus could not be reached." }
            }
        }
    }

    /**
     * Returns true if variable [dummy] is initialized.
     *
     * @return [Boolean]
     */
    fun isDummyInitialized(): Boolean {
        return ::dummy.isInitialized
    }
}